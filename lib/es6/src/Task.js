// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Int$Std from "./Int.js";
import * as Array$Std from "./Array.js";
import * as Async$Std from "./Async.js";
import * as Result$Std from "./Result.js";
import * as Console$Std from "./Console.js";

function to(t) {
  return Async$Std.to({
              TAG: /* Ok */0,
              _0: t
            });
}

function toError(t) {
  return Async$Std.to({
              TAG: /* Error */1,
              _0: t
            });
}

var fromResult = Async$Std.to;

function flatten(to) {
  return Async$Std.flatMap(to, (function (r) {
                if (r.TAG === /* Ok */0) {
                  return r._0;
                } else {
                  return Async$Std.to({
                              TAG: /* Error */1,
                              _0: r._0
                            });
                }
              }));
}

function map(a, fn) {
  return Async$Std.map(a, (function (res) {
                return Result$Std.map(res, fn);
              }));
}

function flatMap(a, fn) {
  return flatten(Async$Std.map(a, (function (res) {
                    return Result$Std.map(res, fn);
                  })));
}

function mapError(a, fn) {
  return Async$Std.map(a, (function (res) {
                return Result$Std.mapError(res, fn);
              }));
}

function flatMapError(a, fn) {
  return flatten(Async$Std.map(a, (function (res) {
                    return Result$Std.mapError(res, fn);
                  })));
}

function fold(a, fn) {
  return Async$Std.map(a, (function (res) {
                return Result$Std.fold(res, fn);
              }));
}

function flatFold(a, fn) {
  return flatten(Async$Std.map(a, (function (res) {
                    return Result$Std.fold(res, fn);
                  })));
}

function seq(a) {
  return Async$Std.map(Promise.all(a), Result$Std.seq);
}

function seq2(param) {
  return Async$Std.map(Promise.all([
                  param[0],
                  param[1]
                ]), Result$Std.seq2);
}

function seq3(param) {
  return Async$Std.map(Promise.all([
                  param[0],
                  param[1],
                  param[2]
                ]), Result$Std.seq3);
}

function seq4(param) {
  return Async$Std.map(Promise.all([
                  param[0],
                  param[1],
                  param[2],
                  param[3]
                ]), Result$Std.seq4);
}

function pool(tasks, count) {
  var curTasks = Promise.all(Array$Std.map(Array$Std.slice(tasks, 0, count), (function (f) {
              return new Promise((function (resolve) {
                            return Curry._1(resolve, Curry._1(f, undefined));
                          }));
            })));
  var rest = Array$Std.slice(tasks, count, Array$Std.length(tasks) - count | 0);
  Console$Std.log("pool: " + Int$Std.toString(Array$Std.length(rest)));
  return flatten(Async$Std.flatMap(curTasks, (function (res1) {
                    var tasks = Async$Std.map(Promise.all(res1), Result$Std.seq);
                    return map(tasks, (function (res1) {
                                  var match = Array$Std.length(rest);
                                  if (match !== 0) {
                                    return map(pool(rest, count), (function (res2) {
                                                  return Array$Std.flatten([
                                                              res1,
                                                              res2
                                                            ]);
                                                }));
                                  } else {
                                    return Async$Std.to({
                                                TAG: /* Ok */0,
                                                _0: res1
                                              });
                                  }
                                }));
                  })));
}

export {
  to ,
  toError ,
  fromResult ,
  flatten ,
  map ,
  flatMap ,
  mapError ,
  flatMapError ,
  fold ,
  flatFold ,
  seq ,
  seq2 ,
  seq3 ,
  seq4 ,
  pool ,
  
}
/* No side effect */
